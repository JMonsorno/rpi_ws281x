<?php

class ApiRequest {

  private $parts = [];
  private $method = '';

  private $response = [];

  public function __construct(string $requestUri) {
    $this->parts = array_values(array_filter(explode('/', $requestUri)));
    $this->method = $_SERVER['REQUEST_METHOD'];
  }

  public function Process() {
    $apiKey = $this->parts[1];
    $mimic = new HueMimic();
    if (!$mimic->CheckApi($apiKey)) {
      $this->ErrorOut(1);
    }
    if (count($this->parts) > 2) {
      $object = $this->parts[2];
    } else {
      $this->ProcessAll();
    }
    switch(strtolower($object)) {
      case 'lights':
        $this->ProcessLights();
        break;
    }
  }

  private function ProcessAll() {
    //lights, groups, config, scenes, rules, sensors, resourcelinks
    if ($this->method != 'GET') {
      $this->ErrorOut(4);
    }
    $response = (object)['lights'=>(object)$this->GetLights()];
    echo json_encode($response);   
  }

  private function ProcessLights() {
    $range = $this->GetRange();
    if (count($range) == 0 && $this->method != 'GET') {
      $this->ErrorOut(4);
    }
    $lights = $this->GetLights();
    if (count($range) > 0) {
      $lights = array_filter($lights, function($lightNumber) use($range) {return in_array($lightNumber + 0, $range); }, ARRAY_FILTER_USE_KEY);
    }
    echo json_encode((object)$lights);
  }

  private function ProcessGroups() {
  }

  private function ProcessConfig() {
  }

  private function ProcessScenes() {
  }

  private function ProcessRules() {
  }

  private function ProcessSensors() {
  }

  private function ProcessResouceLinks() {
  }

  private function GetLights(): array {
    DI::GetStrand()->Set(Color::WHITE());
    return DI::GetStrand()->GetLeds();
  }

  private function GetGroups(): array {
    return [];
  }

  private function GetConfig(): array {
    return [];
  }

  private function GetScenes(): array {
    return [];
  }

  private function GetRules(): array {
    return [];
  }

  private function GetSensors(): array {
    return [];
  }

  private function GetResouceLinks(): array {
    return [];
  }

  private function ErrorOut(int $errorCode, string $message = '') {
    $error = ['type'=>$errorCode, 'address'=>'/' . implode('/', array_slice($this->parts, 2))];
    switch($errorCode) {
      case 1:
        $error['description'] = 'unauthorized user';
        break;
      case 4:
        $error['description'] = 'method, ' . $this->method . ', not available for resource, ' . $error['address'];
        break;
      case 6:
        $error['description'] = 'method, ' . $this->method . ', not available for resource, ' . $error['address'];
        break;
      case 4:
        $error['description'] = 'method, ' . $this->method . ', not available for resource, ' . $error['address'];
        break;
      case 4:
        $error['description'] = 'method, ' . $this->method . ', not available for resource, ' . $error['address'];
        break;
      default:
        $error['description'] = $message;
    }
    echo json_encode([(object)([ 'error' => $error ])]);
    exit(1);
  }

  private function AddSuccessfulResponse(string $key, $value) {
    $response[] = (object)['success'=>(object)[$key=>$value]];
  }

  private function AddErrorResponse(int $errorCode, string $part = '') {
     $error = ['type'=>$errorCode, 'address'=>'/' . implode('/', array_slice($this->parts, 2))];
     if (strlen($part) > 0) {
       $error['address'] .= '/' . $part;
     }
    switch($errorCode) {
      case 1:
        $error['description'] = 'unauthorized user';
        break;
      case 4:
        $error['description'] = 'method, ' . $this->method . ', not available for resource, ' . $error['address'];
        break;
      case 6:
        $error['description'] = 'method, ' . $this->method . ', not available for resource, ' . $error['address'];
        break;
      case 4:
        $error['description'] = 'method, ' . $this->method . ', not available for resource, ' . $error['address'];
        break;
      case 4:
        $error['description'] = 'method, ' . $this->method . ', not available for resource, ' . $error['address'];
        break;
      default:
        $error['description'] = $message;
    }
    $response[] = (object)[ 'error' => $error ];
  }

  private function GetRange(): array {
    if (count($this->parts) <= 3) {
      return [];
    }
    $rangeAsString = $this->parts[3];
    if (is_numeric($rangeAsString)) {
      return [$rangeAsString + 0];
    }
    $rangeParts = explode(',', $rangeAsString);
    $range = [];
    foreach($rangeParts as $rangePart) {
      $miniRange = explode('-', $rangePart);
      if(count($miniRange) > 1) {
        list($min, $max) = $miniRange;
      } else {
        $min = $miniRange[0];
        $max = $min;
      }
      $range = array_merge($range, range($min, $max));
    }
    return $range;
  }
}
